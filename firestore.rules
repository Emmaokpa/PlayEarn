
/**
 * @fileoverview Firestore Security Rules for the RewardPlay application.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for user-specific data and allows public read access for reward metadata.
 * Authentication is handled via Firebase's email/password provider.
 *
 * Data Structure:
 * - /users/{userId}: User profiles, accessible only to the user themselves. The {userId} is the Firebase Auth UID.
 * - /games/{gameId}: Game definitions, publicly readable, writeable by admins only.
 * - /rewards/{rewardId}: Reward definitions, publicly readable, writeable by admins only.
 * - /stickerPacks/{stickerPackId}: Sticker packs, publicly readable, writeable by admins only.
 * - /inAppPurchases/{purchaseId}: All IAPs (coins, spins), publicly readable, writeable by admins only.
 * - /affiliateOffers/{offerId}: Affiliate offers, publicly readable, writeable by admins only.
 * - /affiliateSubmissions/{submissionId}: Global collection for submissions, only admins can read/write.
 * - /fulfillments/{fulfillmentId}: Global queue for physical reward redemptions. Users create, admins update.
 * - All user subcollections (/users/{userId}/**): Accessible only to the owning user.
 *
 * Key Security Decisions:
 * - User listing is allowed for leaderboards but protected so only signed-in users can view it.
 * - Admin roles are implemented for the collections.
 * - All writes to user-owned data require a verified user ID that matches the path.
 * - Schema validation ensures data integrity upon creation.
 *
 * Denormalization for Authorization:
 * - User ownership is enforced via path-based rules (e.g., /users/{userId}), avoiding the need for `get()` calls to verify ownership.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the request is authenticated.
     * @return {boolean} True if the request is authenticated, false otherwise.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user ID matches the provided user ID.
     * @param {string} userId The user ID to compare against.
     * @return {boolean} True if the user ID matches, false otherwise.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Checks if the requesting user has an admin role.
     * It reads the user's profile from the /users collection.
     * @return {boolean} True if the user is an admin, false otherwise.
     */
    function isAdmin() {
      return isSignedIn() && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.isAdmin == true;
    }
    
    /**
     * @description Validates the fields of a UserProfile document on creation.
     * @param {map} data The incoming resource data.
     * @return {boolean} True if the data is valid, false otherwise.
     */
    function isValidUserProfile(data) {
        return data.telegramId is string &&
               data.username is string &&
               data.name is string &&
               data.avatarUrl is string &&
               data.coins is number &&
               data.referralCode is string &&
               data.isVip == false && // New users cannot be VIPs
               data.registrationDate == request.time &&
               data.gamePlaysToday == 0 && // New users start with 0 plays
               data.isAdmin == false; // New users cannot be admins
    }


    /**
     * @description Rules for user profiles.
     * @path /users/{userId}
     * @principle Enforces document ownership for writes and validates relational integrity.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      // Allow signed-in users to list profiles for the leaderboard
      allow list: if isSignedIn();

      allow create: if isOwner(userId) 
                      && request.resource.data.id == userId
                      && isValidUserProfile(request.resource.data);

      allow update: if isOwner(userId); // Simplified to allow coin updates

      allow delete: if false; // Deleting users should be handled carefully, disabling for now.

      // User can create their own submission records.
      // Admins can update them (to approve/reject).
      match /affiliateSignups/{offerId} {
        allow create: if isOwner(userId);
        allow update: if isAdmin();
        allow read, delete: if isOwner(userId) || isAdmin();
      }

      // Rules for all other subcollections under a user's document
      match /{allPaths=**} {
        allow read, write: if isOwner(userId);
      }
    }
    
    /**
     * @description Rules for games.
     * @path /games/{gameId}
     * @principle Publicly readable, but only admins can create/update.
     */
    match /games/{gameId} {
      allow get, list: if isSignedIn();
      allow create, update, delete: if isAdmin();
    }

    /**
     * @description Rules for rewards.
     * @path /rewards/{rewardId}
     * @principle Publicly readable, but only admins can create/update.
     */
    match /rewards/{rewardId} {
      allow get, list: if true;
      allow create, update, delete: if isAdmin();
    }

    /**
     * @description Rules for sticker packs.
     * @path /stickerPacks/{stickerPackId}
     * @principle Publicly readable, but only admins can create/update.
     */
    match /stickerPacks/{stickerPackId} {
        allow get, list: if true;
        allow create, update, delete: if isAdmin();
    }
    
    /**
     * @description Rules for all in-app purchases (coins, spins, etc).
     * @path /inAppPurchases/{purchaseId}
     * @principle Publicly readable, but only admins can create/update.
     */
    match /inAppPurchases/{purchaseId} {
        allow get, list: if true;
        allow create, update, delete: if isAdmin();
    }

    /**
     * @description Rules for affiliate offers.
     * @path /affiliateOffers/{offerId}
     * @principle Publicly readable, but only admins can create/update.
     */
    match /affiliateOffers/{offerId} {
        allow get, list: if isSignedIn();
        allow create, update, delete: if isAdmin();
    }

    /**
     * @description Validates an affiliate submission on creation.
     * @param {map} data The incoming resource data.
     * @return {boolean} True if the data is valid, false otherwise.
     */
    function isValidAffiliateSubmission(data) {
      return data.userId == request.auth.uid &&
             data.userName is string &&
             data.offerId is string &&
             data.offerTitle is string &&
             data.status == 'pending' &&
             data.submittedAt == request.time &&
             data.rewardAmount is number &&
             (data.proofText is string || data.proofImageUrl is string);
    }


    /**
     * @description Rules for affiliate offer submissions.
     * @path /affiliateSubmissions/{submissionId}
     * @principle Admins have full control. Users can only create their own with valid data.
     */
     match /affiliateSubmissions/{submissionId} {
       allow read, list, update, delete: if isAdmin();
       allow create: if isSignedIn() && isValidAffiliateSubmission(request.resource.data);
     }
     
    /**
     * @description Validates a reward fulfillment request on creation.
     * @param {map} data The incoming resource data.
     * @return {boolean} True if the data is valid, false otherwise.
     */
    function isValidFulfillmentRequest(data) {
        return data.userId == request.auth.uid &&
               data.userEmail is string && // Check for email presence
               data.userEmail == request.auth.token.email &&
               data.rewardId is string &&
               data.rewardDetails is map &&
               data.status == 'pending' &&
               data.requestedAt == request.time;
    }

    /**
     * @description Rules for reward fulfillment requests.
     * @path /fulfillments/{fulfillmentId}
     * @principle Users can create their own requests. Admins can read, update, and delete.
     */
    match /fulfillments/{fulfillmentId} {
      allow create: if isSignedIn() && isValidFulfillmentRequest(request.resource.data);
      allow read, update, delete: if isAdmin();
    }

     /**
     * @description Validates a withdrawal request on creation.
     * @param {map} data The incoming resource data.
     * @return {boolean} True if the data is valid, false otherwise.
     */
    function isValidWithdrawalRequest(data) {
        let userProfile = get(/databases/$(database)/documents/users/$(request.auth.uid)).data;
        return data.userId == request.auth.uid &&
               data.userName == userProfile.name &&
               data.amountCoins is number &&
               data.amountCoins >= 1500 && // Minimum withdrawal
               data.amountCoins <= userProfile.coins && // Cannot withdraw more than they have
               data.amountUsd is number &&
               data.feeUsd is number &&
               data.netUsd is number &&
               data.method is string &&
               data.recipientAddress is string &&
               data.status == 'pending' &&
               data.requestedAt == request.time;
    }

    /**
     * @description Rules for cash withdrawal requests.
     * @path /withdrawals/{withdrawalId}
     * @principle Users can create their own valid requests. Admins can read, update, and delete.
     */
    match /withdrawals/{withdrawalId} {
      allow create: if isSignedIn() && isValidWithdrawalRequest(request.resource.data);
      allow read, list, update, delete: if isAdmin();
    }
  }
}
