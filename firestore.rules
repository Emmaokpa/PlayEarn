
/**
 * @fileoverview Firestore Security Rules for the RewardPlay application.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for user-specific data and allows public read access for game and reward metadata.
 * Authentication is handled via Firebase's email/password provider.
 *
 * Data Structure:
 * - /users/{userId}: User profiles, accessible only to the user themselves. The {userId} is the Firebase Auth UID.
 * - /games/{gameId}: Game metadata, publicly readable, writeable by admins only.
 * - /rewards/{rewardId}: Reward definitions, publicly readable, writeable by admins only.
 * - /stickerPacks/{stickerPackId}: Sticker packs, publicly readable, writeable by admins only.
 * - /coinPacks/{coinPackId}: Coin packs, publicly readable, writeable by admins only.
 * - /affiliateOffers/{offerId}: Affiliate offers, publicly readable, writeable by admins only.
 * - All user subcollections (/users/{userId}/**): Accessible only to the owning user.
 *
 * Key Security Decisions:
 * - User listing is allowed for leaderboards but protected so only signed-in users can view it.
 * - Admin roles are now implemented for the /games and /affiliateOffers collections.
 * - All writes to user-owned data require a verified user ID that matches the path.
 * - Schema validation ensures data integrity upon creation.
 *
 * Denormalization for Authorization:
 * - User ownership is enforced via path-based rules (e.g., /users/{userId}), avoiding the need for `get()` calls to verify ownership.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the request is authenticated.
     * @return {boolean} True if the request is authenticated, false otherwise.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user ID matches the provided user ID.
     * @param {string} userId The user ID to compare against.
     * @return {boolean} True if the user ID matches, false otherwise.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Checks if the requesting user has an admin role.
     * It reads the user's profile from the /users collection.
     * @return {boolean} True if the user is an admin, false otherwise.
     */
    function isAdmin() {
      return isSignedIn() && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.isAdmin == true;
    }
    
    /**
     * @description Validates the fields of a UserProfile document on creation.
     * @param {map} data The incoming resource data.
     * @return {boolean} True if the data is valid, false otherwise.
     */
    function isValidUserProfile(data) {
        return data.telegramId is string &&
               data.username is string &&
               data.name is string &&
               data.avatarUrl is string &&
               data.coins is number &&
               data.referralCode is string &&
               data.isVip == false && // New users cannot be VIPs
               data.registrationDate == request.time &&
               data.isAdmin == false; // New users cannot be admins
    }


    /**
     * @description Rules for user profiles.
     * @path /users/{userId}
     * @principle Enforces document ownership for writes and validates relational integrity.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      // Allow signed-in users to list profiles for the leaderboard
      // and also allow referral code checks.
      allow list: if isSignedIn();

      allow create: if isOwner(userId) 
                      && request.resource.data.id == userId
                      && isValidUserProfile(request.resource.data);

      allow update: if isOwner(userId)
                      // Prevent changing critical IDs or admin status by user
                      && request.resource.data.id == resource.data.id
                      && request.resource.data.telegramId == resource.data.telegramId
                      && request.resource.data.isAdmin == resource.data.isAdmin
                      // Allow coin updates from referrals (by anyone, checked in backend logic)
                      || (request.auth != null && request.resource.data.coins == resource.data.coins + 1000);

      allow delete: if false; // Deleting users should be handled carefully, disabling for now.

      // Rules for all subcollections under a user's document
      match /{allPaths=**} {
        allow read, write: if isOwner(userId);
      }
    }

    /**
     * @description Rules for games.
     * @path /games/{gameId}
     * @principle Publicly readable, but only admins can create/update.
     */
    match /games/{gameId} {
      allow get, list: if true;
      allow create, update, delete: if isAdmin();
    }

    /**
     * @description Rules for rewards.
     * @path /rewards/{rewardId}
     * @principle Publicly readable, but only admins can create/update.
     */
    match /rewards/{rewardId} {
      allow get, list: if true;
      allow create, update, delete: if isAdmin();
    }

    /**
     * @description Rules for sticker packs.
     * @path /stickerPacks/{stickerPackId}
     * @principle Publicly readable, but only admins can create/update.
     */
    match /stickerPacks/{stickerPackId} {
        allow get, list: if true;
        allow create, update, delete: if isAdmin();
    }
    
    /**
     * @description Rules for coin packs.
     * @path /coinPacks/{coinPackId}
     * @principle Publicly readable, but only admins can create/update.
     */
    match /coinPacks/{coinPackId} {
        allow get, list: if true;
        allow create, update, delete: if isAdmin();
    }

    /**
     * @description Rules for affiliate offers.
     * @path /affiliateOffers/{offerId}
     * @principle Publicly readable, but only admins can create/update.
     */
    match /affiliateOffers/{offerId} {
        allow get, list: if true;
        allow create, update, delete: if isAdmin();
    }
  }
}
